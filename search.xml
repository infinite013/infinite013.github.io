<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode20题-有效的括号</title>
      <link href="/2020/04/04/leetcode20%E9%A2%98-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/2020/04/04/leetcode20%E9%A2%98-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><pre><code>左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。</code></pre><p>注意空字符串可被认为是有效字符串<br><img src="https://i.loli.net/2020/04/04/BTMDY1QtOvjkdn9.png" alt="示例"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#解法1</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public boolean isValid(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            char temp = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="string">'('</span> || temp == <span class="string">'&#123;'</span> || temp == <span class="string">'['</span>)</span><br><span class="line">                stack.push(temp);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                char top_char = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(temp == <span class="string">')'</span> &amp;&amp; top_char!=<span class="string">'('</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(temp == <span class="string">'&#125;'</span> &amp;&amp; top_char!=<span class="string">'&#123;'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(temp == <span class="string">']'</span> &amp;&amp; top_char!=<span class="string">'['</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CBAM-注意力机制</title>
      <link href="/2020/03/31/CBAM-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/03/31/CBAM-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="CBAM总览"><a href="#CBAM总览" class="headerlink" title="CBAM总览"></a>CBAM总览</h1><p>文章中提到的主要的贡献有以下三点：<br>1、提出了一个简单但是有效的注意力模块(CBAM)，这个模块可以被广泛的使用来增强CNN的表达能力。<br>2、通过消融实验验证了注意力模块的有效性。<br>3、验证了在benchmarks上增加这个轻量模块可以增强实验结果。<br><img src="https://i.loli.net/2020/03/31/ICt7LHqbX5lYj8p.png" alt="CBAM模块结构图"><br>给定一个(C,H,W)的feature map作为输入，CBAM按顺序地生成1D的channel attention map C*1*1和2D的spatial attention map Ms 1*H*W，可以用下面这个公式来表达:<br><img src="https://i.loli.net/2020/03/31/UGIthuB4EJTHpXa.png" alt=""><br>下图表示了模块的具体结构，分为channel和spatial两部分：<br><img src="https://i.loli.net/2020/03/31/Pg8nDMCyQGioepd.png" alt="模块具体结构"></p><h1 id="Channel-attention-module"><a href="#Channel-attention-module" class="headerlink" title="Channel attention module"></a>Channel attention module</h1><p>作者通过features map通道间的关系来生成 channel attention map。Feature map 的每一个通道都被看作是一个feature detector，channel attention关注给定的图像中什么是有意义的。作者为了有效的计算channel attention，压缩了输入特征的图的spatial dimention（空间维度）。为了聚合（aggregate）空间信息，作者同时使用了平均池化以及最大池化。<br>    首先使用池化操作去聚合空间信息，生成两个不同的空间上下文描述符(spatial context descriptors)，然后将描述符送进一个共享的前向网络产生channel attention map Mc，他的维度为C*1*1。这个共享的网络是含有一个隐藏层的多层感知器multi-layer perceptron (MLP) 。通过隐藏层的设定减少了一些参数。之后对特征参数向量进行融合（将两个向量对应元素相加，如上图所示）。总之可以将channel attention表述为下式：<br><img src="https://i.loli.net/2020/03/31/Q13iq2BpVTvJM7A.png" alt=""></p><h1 id="Spatial-attention-module"><a href="#Spatial-attention-module" class="headerlink" title="Spatial attention module"></a>Spatial attention module</h1><p> 通过使用特征间的inter-spatial 关系来生成spatial attention map。作者说spatial attention关注于哪里是有信息的地方，与channel attention 互补。具体可以表示为下式：<img src="https://i.loli.net/2020/03/31/Z723kS8GrxpfvJB.png" alt=""><br> 作者通过实验验证了先通过channel attention module再通过spatial attention module效果最好。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p> <a href="https://github.com/luuuyi/CBAM.PyTorch" target="_blank" rel="noopener">https://github.com/luuuyi/CBAM.PyTorch</a></p>]]></content>
      
      
      <categories>
          
          <category> cv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cv </tag>
            
            <tag> 注意力机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fasterrcnn详解</title>
      <link href="/2020/03/31/fasterrcnn%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/03/31/fasterrcnn%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="fasterrcnn结构概览"><a href="#fasterrcnn结构概览" class="headerlink" title="fasterrcnn结构概览"></a>fasterrcnn结构概览</h2><p><img src="https://i.loli.net/2020/03/31/3joDRnFCWf2zdks.png" alt="Faster RCNN结构图"><br>    上图为论文中的总体结构，在作者看来，主要分为四个部分：</p><ol><li><p>Conv layers。作为一种CNN网络目标检测方法，Faster RCNN首先使用一组基础的conv+relu+pooling层提取image的feature maps。该feature maps被共享用于后续RPN层和全连接层。</p></li><li><p>Region Proposal Networks。RPN网络用于生成region proposals。该层通过softmax判断anchors属于positive或者negative，再利用bounding box regression修正anchors获得精确的proposals。</p></li><li><p>Roi Pooling。该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。</p></li><li><p>Classification。利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。</p><p> 另一种结构图如下所示：<img src="https://i.loli.net/2020/03/31/eWSPnOvXcVEN3tu.png" alt="框架"><br> 表示为python版本中的VGG16模型中的faster_rcnn_test.pt的网络结构，可以清晰的看到该网络对于一副任意大小PxQ的图像，首先缩放至固定大小MxN，然后将MxN图像送入网络；而Conv layers中包含了13个conv层+13个relu层+4个pooling层；RPN网络首先经过3x3卷积，再分别生成positive anchors和对应bounding box regression偏移量，然后计算出proposals；而Roi Pooling层则利用proposals从feature maps中提取proposal feature送入后续全连接和softmax网络作classification（即分类proposal到底是什么object）。</p></li></ol><h2 id="RPN-Region-Proposal-Networks-到底是什么"><a href="#RPN-Region-Proposal-Networks-到底是什么" class="headerlink" title="RPN(Region Proposal Networks)到底是什么"></a>RPN(Region Proposal Networks)到底是什么</h2><p>   到底什么是RPN呢，他又起了什么作用呢？我们首先来看RPN的网络结构<img src="https://i.loli.net/2020/03/31/DuUgAoyveBfVlSq.png" alt="RPN结构"><br>    具体来说，我们可以将它分解为两条路径，上方的一条路径通过softmax对anchor进行一个<strong>二分类</strong>，区分positive和negative的anchor，下方路径计算anchor对于bbx的偏移量，获得精确的proposal，<strong>最后的Proposal层则负责综合positive anchors和对应bounding box regression偏移量获取proposals，同时剔除太小和超出边界的proposals。其实整个网络到了Proposal Layer这里，就完成了相当于目标定位的功能</strong>。<br>    其实RPN最终就是在原图尺度上，设置了密密麻麻的候选Anchor。然后用cnn去判断哪些Anchor是里面有目标的positive anchor，哪些是没目标的negative anchor。</p><h3 id="anchor"><a href="#anchor" class="headerlink" title="anchor"></a>anchor</h3><p>   提到RPN，就离不开anchor。所谓anchors，实际上就是一组由rpn/generate_anchors.py生成的矩形，直接运行mmdetection中的anchor生成代码，可以得到以下输出：<br>`[[ -84.  -40. 99.  55.]</p><p> [-176.  -88.  191.  103.]<br> [-360. -184.  375.  199.]<br> [ -56.  -56.   71.   71.]<br> [-120. -120.  135.  135.]<br> [-248. -248.  263.  263.]<br> [ -36.  -80.   51.   95.]<br> [ -80. -168.   95.  183.]<br> [-168. -344.  183.  359.]]</p><p> `<br><img src="https://i.loli.net/2020/03/31/MEV2By4XP91jZxw.png" alt="anchor示意图"><br>     这就是生成的anchor，其中每行的4个值(x1,y1,x2,y2)表矩形左上和右下角点坐标。9个矩形共有3种形状，长宽比为大约为 三种，如图6。实际上通过anchors就引入了检测中常用到的多尺度方法。<br>    对于维度是(W,H)的特征图来说，其生成的anchor个数为WxHx9个，这些anchor对应这特征图上的各个部分，然后对这些anchor进行判定，判定其中是否包含正样本(即包含可能的目标)<br>    当然，在获得positive anchor后，我们要对anchor进行微调，让他更接近真实的bbx，这就称作bounding box regression。</p><h3 id="bounding-box-regression"><a href="#bounding-box-regression" class="headerlink" title="bounding box regression"></a>bounding box regression</h3><p>如下图所示绿色框为飞机的Ground Truth(GT)，红色为提取的positive anchors，即便红色的框被分类器识别为飞机，但是由于红色的框定位不准，这张图相当于没有正确的检测出飞机。所以我们希望采用一种方法对红色的框进行微调，使得positive anchors和GT更加接近。<br><img src="https://i.loli.net/2020/03/31/Z2yABCnGRmb6ruE.png" alt="GT与anchor对比图"><br>   对于窗口一般使用四维向量(x,y,w,h)表示，分别表示窗口的中心点坐标和宽高，对于下图，红色的框A代表原始的positive Anchors，绿色的框G代表目标的GT，我们的目标是寻找一种关系，使得输入原始的anchor A经过映射得到一个跟真实窗口G更接近的回归窗口G’，即：<br>  <img src="https://i.loli.net/2020/03/31/bMHV5RfU2Y6Nim3.png" alt=""><br>   那么经过何种变换F才能从图中的anchor A变为G’呢？ 比较简单的思路就是:<br><img src="https://i.loli.net/2020/03/31/si21RvB6QONFq4k.png" alt="变换"><br><img src="https://i.loli.net/2020/03/31/L78RpPwXVDZnlgd.png" alt=""><br><img src="https://i.loli.net/2020/03/31/6N9OJCjHFVy8mIx.png" alt=""><br><img src="https://i.loli.net/2020/03/31/iI1Pdljfm6TEkQM.png" alt=""></p><h2 id="模型训练中的损失函数"><a href="#模型训练中的损失函数" class="headerlink" title="模型训练中的损失函数"></a>模型训练中的损失函数</h2><p>在模型训练的过程中，如下图所示，<br>有两个Classification loss和两个Bounding-box regression loss，区别为：<br>Input Image经过CNN特征提取，首先来到Region Proposal网络。由Regio Proposal Network输出的Classification，这并不是判定物体在数据集上对应的类中哪一类，而是输出一个Binary的值p，可以理解为p在0，1之间 ，人工设定一个threshold=0.5。RPN网络做的事情就是，如果一个Region的 p&gt;=0.5，则认为这个Region中可能是80个类别中的某一类，具体是哪一类现在还不清楚。到此为止，Network只需要把这些可能含有物体的区域选取出来就可以了，这些被选取出来的Region又叫做ROI （Region of Interests），即感兴趣的区域。当然了，RPN同时也会在feature map上框定这些ROI感兴趣区域的大致位置，即Bounding-box。<br><img src="https://i.loli.net/2020/03/31/hAXHFNVTDkYv48S.png" alt="损失函数框图"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; [](https://zhuanlan.zhihu.com/p/31426458)</span></span><br><span class="line"><span class="quote">&gt; [](https://zhuanlan.zhihu.com/p/69250914)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cv </tag>
            
            <tag> fasterrcnn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客上传</title>
      <link href="/2020/03/26/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0/"/>
      <url>/2020/03/26/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>在git bash下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"新的博客"</span></span><br></pre></td></tr></table></figure><p>之后对新的博客.md进行编辑，修改对应的tag以及categories<br>修改完成之后可以对博客进行预览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>上传的具体方法为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p>就大功告成了</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
